---
title: "Database"
description: "Blazor Spark database"
---

# Database

Most web applications interact with a database in some way. Blazor Spark utilizes EF Core to make interacting with your database as simple as possible.
If you've never used EF Core before, you can check out Microsofts documentation [here](https://learn.microsoft.com/en-us/ef/core/).

Spark currently supports the following databases out of the box.
- SQLite
- PostgreSQL
- MySQL

## Configuration
By default, when a new Spark app is created, it comes with an SQLite setup. Databases configurations are setup in your `.env` file.
```ini
DB_CONNECTION=sqlite
DB_HOST=localhost
DB_PORT=3306
DB_DATABASE=Spark.db
DB_USERNAME=root
DB_PASSWORD=
```

### PostgreSQL ENV Example
```ini
DB_CONNECTION=postgres
DB_HOST=127.0.0.1
DB_PORT=5432
DB_DATABASE=your_db_name
DB_USERNAME=your_user
DB_PASSWORD=your_user_password
```
### MySQL ENV Example
```ini
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=your_db_name
DB_USERNAME=your_user
DB_PASSWORD=your_user_password
```

## Database Context
When a Spark app starts, a DB Context Factory is created and added to your apps DI container via Sparks internal service registration.


> Spark uses a DB Context Facory because Blazor applications do not create a service scope that aligned with the desired DB Context lifetime and will result in errors in your Blazor app.
> You can read more about this [here](https://learn.microsoft.com/en-us/ef/core/dbcontext-configuration/#using-a-dbcontext-factory-eg-for-blazor).

You can inject the DB Context Factory in your services like the following:

```csharp
public class UsersService
{
    private readonly IDbContextFactory<ApplicationDbContext> _factory;

    public UsersService(IDbContextFactory<ApplicationDbContext> factory)
    {
        _factory = factory;
    }
}
```

## Models & Migrations

Spark uses models and migrations to setup and maintain the database schema through EF Core.

To create a new model, simply create a new class in the `Application/Models` folder. You can extend the `BaseModel` class. This will add `CreatedAt` and `UpdatedAt` properties for you.

```csharp
public class Developer : BaseModel
{
    public int Id { get; set; }

    public string Name { get; set; }

    public string Title { get; set; }
}
```

Then, register your model in the `ApplicationDbContext` class in the `Application/Database` folder:
```csharp
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
    { }

    public virtual DbSet<Developer> Developers { set; get; }
    ...
```

Finally, you can create and run a migration. This essentially acts as source control for your database schema. When a migration is created, a new file with the schema changes is created in the `Application/Migrations` folder. Running a migration will apply those changes to your database.

Spark comes with handy CLI commands to easily create and run your migrations:
```bash
spark make:migration AddDeveloperTable
spark run:migration
```

## Querying Data
Because Spark sets up your EF Core dependency, database connection, and DB Context for you, interacting with your database is very simple out of the box.
```csharp
public class DeveloperService
{
    private readonly IDbContextFactory<ApplicationDbContext> _factory;

    public DeveloperService(IDbContextFactory<ApplicationDbContext> factory)
    {
        this._factory = factory;
    }

    public async Task<List<Developer>> GetAll()
    {
        using var context = _factory.CreateDbContext();
        return await context.Developers.ToListAsync();
    }
}
```

Once you register the DeveloperService to the DI container in your `Application/Startup/AppServiceRegistration.cs` class, you can query data from any Blazor Page or component by injecting the service.
```csharp
@page "/developers"
@inject DeveloperService developerService

<div class="">
    @if (developers == null)
    {
        <p>Loading...</p>
    }
    else
    {
        <ul>
        @foreach (var developer in Developers)
        {
            <li>developer.Name</li>
        }
        </ul>
    }
</div>

@code {
	private List<Developer> developers;

	protected override async Task OnInitializedAsync()
	{
		developers = await developerService.GetAll();
	}
}
```